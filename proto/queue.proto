/*
Copyright 2024 Derrick J Wippler

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

option go_package = "github.com/kapetan-io/querator/proto";
import "google/protobuf/timestamp.proto";

package querator;

message QueueProduceRequest {
  // The name of the queue this item is to be queued to.
  string queueName = 1  [json_name = "queue_name"];
  // How long the client should wait until the items in this produce request are accepted into the queue.
  // If this duration elapses and the server hasn't responded the client should assume the item was not
  // produced. If the server detects a client has been waiting for to long, it will cancel the produce
  // request and return an error to the client.
  //
  // Example: '1m', '20s'. Default timeout is '1m' and the maximum timeout is 15 minutes.
  string requestTimeout = 2 [json_name = "request_timeout"]; // TODO: OpenAPI
  // A list of items to be queued
  repeated QueueProduceItem items = 3;
}

message QueueProduceItem {
  // A user specified field which indicates the encoding used to encode the 'payload'
  string encoding = 1;
  // A Kind or Type the payload contains. Consumers can use this field to determine handling
  // of the payload prior to unmarshalling. Examples: 'webhook-v2', 'webhook-v1',
  string kind = 2;
  // This is a user specified field that can be used by the consumer to determine handling
  // of the message without needing to unmarshall the payload.
  // Examples: 'account-0001', 'john.smith'
  string reference = 3;
  // The payload of the item as an array of raw bytes with no predetermined character set.
  // Clients who communicate with Querator with `Content-Type: application/protobuf`
  // (which is the default for golang clients) should use this field instead of `strings`.
  //
  // NOTE: If `Content-Type: application/json` is used when communicating with Querator, the
  // 'bytes' field will be encoded as base64. This is because byte fields (unlike string fields)
  // can contain non-UTF8 binary data, and since that cannot be directly represented in JSON, we
  // have to base64 encode it.
  bytes bytes = 4;
  // This is an a convenience field useful for clients that are communicating with Querator via
  // `Content-Type: application/json`. This field assumes a utf8 encoded payload and does not
  // require the payload to be encoded as base64. As such is is an excellent choice for clients
  // who do not have access to a base64 encoder and can't use the `bytes` field for their payload.
  //
  // NOTE: Both `bytes` and `utf8` can be set, but `bytes` takes precedence. If `bytes` is set,
  // then that will be used as the payload. If `utf8` is set and `bytes` is empty, then `utf8`
  // will be used. If both `bytes` and `utf8` are set, then `bytes` will be used and `utf8` will
  // be dropped.
  // Example: 'Hello, I am a UTF-8 payload' , '{"key", "value"}'
  string utf8 = 5;
}

message QueueReserveRequest {
  // The name of the queue to reserve work from
  string queueName = 1  [json_name = "queue_name"];

  // The number of queue items requested from the queue.
  int32 batchSize = 2 [json_name = "batch_size"];

  // A user supplied unique string which identifies the client making this request. This
  // must be unique for each client reserving items. Multiple clients with the same
  // id cannot reserve from the same queue. If you need more throughput, increase the batch
  // size instead.
  string clientId = 3 [json_name = "client_id"]; // TODO: OpenAPI

  // The duration the client expects to wait for a queue item to be reserved before timing out.
  // Maximum timeout duration is 15 minutes
  // Example: '5m', '10s'
  string requestTimeout = 4 [json_name = "request_timeout"]; // TODO: OpenAPI
}

message QueueReserveItem {
  // A user specified field which indicates the encoding the user used to encode the 'payload'
  string encoding = 1;

  // A Kind or Type the payload contains. Consumers can use this field to determine handling
  // of the payload prior to unmarshalling. Examples: 'webhook-v2', 'webhook-v1',
  string kind = 2;

  // This is a user specified field that can be used by the consumer to determine handling
  // of the queue item without needing to unmarshall the payload.
  // Examples: 'account-0001', 'john.smith', 'id-hIGTUYm2'
  string reference = 3;

  // A unique id which identifies an item in a queue
  string id = 4;

  // The number of times this item has been deferred or reservation timed out during
  // processing by a consumer.
  int32  attempts = 5;

  // The date time that Querator will offer up this item to another consumer
  // If the consumer reserving this item has not marked it complete.
  //
  // The consumer can use this date to decide if it should finalize it's work
  // if the timeout date has expired.
  google.protobuf.Timestamp reserveDeadline = 6 [json_name = "reserve_deadline"]; // TODO: OpenAPI

  // The payload of the item as an array of raw bytes with no predetermined character set.
  //
  // NOTE: If `Content-Type: application/json` is used when communicating with Querator, the
  // 'bytes' field will be encoded as base64. This is because byte fields (unlike string fields)
  // can contain non-UTF8 binary data, and since that cannot be directly represented in JSON, we
  // have to base64 encode it.
  bytes  bytes = 7;
}

message QueueReserveResponse {
  repeated QueueReserveItem items = 1;
}

message QueueDeferRequest {
  repeated QueueDeferItem items = 1;
}

message QueueDeferItem {
  // A unique id which identifies a unique item in a queue.
  string id = 1;

  // The date after which the item will be added to the queue specified.
  // The date can be empty, the current time or a past date/time, in which
  // case the item will be immediately added to the queue.
  google.protobuf.Timestamp offerAt = 2 [json_name = "offer_at"]; // TODO: OpenAPI

  // Indicates the item is dead, will not be retried regardless of the number of attempts
  // remaining. If set to true the defer will place the item in the dead letter queue for
  // the specified queue.
  bool dead = 3;
}

message QueueCompleteRequest {
  string queueName = 1  [json_name = "queue_name"];
  // The duration the client expects to wait for a queue item to be reserved before timing out.
  // Maximum timeout duration is 15 minutes
  // Example: '5m', '10s'
  string requestTimeout = 2 [json_name = "request_timeout"]; // TODO: OpenAPI

  // A list of ids to mark complete
  repeated string ids = 3;
}

message QueueInfo {
  // The name of the queue
  string queueName = 1  [json_name = "queue_name"];

  // The date the queue was created
  google.protobuf.Timestamp createdAt = 2 [json_name = "created_at"];

  // The date the queue was last updated
  google.protobuf.Timestamp updatedAt = 3 [json_name = "updated_at"];

  // The name of the dead letter queue for this queue. If this is a dead letter queue then
  // this field will be empty when retrieved via '/queue.list'
  string deadQueue = 4 [json_name = "dead_queue"];

  // This is a user supplied field which could contain metadata or specify who owns this queue
  // Examples: "jake@statefarm.com", "stapler@office-space.com", "account-0001"
  string reference = 5;

  // The reservation timeout for this queue.
  // Example: '60m', '24h', '10s'
  string reserveTimeout = 6  [json_name = "reserve_timeout"];

  // How long the item can wait in the queue regardless of attempts before it is moved
  // to the dead letter queue. Example: '24h', '60m', '10s'
  string deadTimeout = 7 [json_name = "dead_timeout"];

  // The maximum number of times this message can be deferred by a consumer before it is
  // placed in the dead letter queue.
  int32  maxAttempts = 8 [json_name = "max_attempts"];

  // The number of partitions the queue is requesting. This might be different than the
  // actual number of partitions if the partition count was recently changed.
  int32  partitions = 9;
}

message QueueClearRequest {
  // The name of the queue
  string queueName = 1  [json_name = "queue_name"];
  // Defer indicates the 'defer' queue will be cleared. If true, any items
  // scheduled to be retried at a future date will be removed.
  bool defer = 2; // TODO: Implement
  // Scheduled indicates any 'scheduled' items in the queue will be
  // cleared. If true, any items scheduled to be enqueued at a future date
  // will be removed.
  bool scheduled = 3; // TODO: Implement
  // Queue indicates any items currently waiting in the FIFO queue will
  // clear. If true, any items in the queue which have NOT been reserved
  // will be removed.
  bool Queue = 4;
  // Destructive indicates the Defer,Scheduled,Queue operations should be
  // destructive in that all data regardless of status will be removed.
  // For example, if used with ClearRequest.Queue = true, then ALL items
  // in the queue regardless of reserve status will be removed. This means
  // that clients who currently have ownership of those items will not be able
  // to "complete" those items, as querator will have no knowledge of those items.
  bool destructive = 5;
}

message QueueStatsRequest {
  string queueName = 1 [json_name = "queue_name"];
}

message QueueStatsResponse {
  // Total is the number of items in the queue
  int32 total = 1;
  // TotalReserved is the number of items in the queue that are in reserved state
  int32 TotalReserved = 2 [json_name = "total_reserved"];
  // AverageAge is the average age of all items in the queue
  string AverageAge = 3 [json_name = "average_age"];
  // AverageReservedAge is the average age of reserved items in the queue
  string AverageReservedAge = 4 [json_name = "average_reserved_age"];
  // ProduceWaiting is the number of `/queue.produce` requests currently waiting
  // to be processed by the sync loop
  int32 ProduceWaiting = 5 [json_name = "produce_waiting"];
  // ReserveWaiting is the number of `/queue.reserve` requests currently waiting
  // to be processed by the sync loop
  int32 ReserveWaiting = 6 [json_name = "reserve_waiting"];
  // CompleteWaiting is the number of `/queue.complete` requests currently waiting
  // to be processed by the sync loop
  int32 CompleteWaiting = 7 [json_name = "complete_waiting"];
  // ReserveBlocked is the number of reservations which are blocked waiting for new item to enter the queue.
  int32 ReserveBlocked = 8 [json_name = "reserve_blocked"];
  // InFlight is the number of requests currently in flight
  int32 InFlight = 9 [json_name = "in_flight"];
}
